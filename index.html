<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Tunnel to Liquid Glass</title>
  <style>
    :root {
      --vh: 1vh; /* 初期値を仮に入れておく */
    }
  
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: 'Noto Sans JP', sans-serif;
      height: calc(var(--vh, 1vh) * 500); /* 500vh → 動的に対応 */
    }
  
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: calc(var(--vh, 1vh) * 100);
      z-index: 0;
    }
  
    #glass-section {
      margin: 50px;
      border-radius: 10px;
      position: relative;
      height: calc(var(--vh, 1vh) * 100); /* ← 100vhではなくこちら */
      top: calc(var(--vh, 1vh) * 200);    /* 200vhに対応 */
      display: none;
      align-items: center;
      justify-content: center;
      background: #ffffff18;
      color: white;
      font-size: 48px;
      z-index: 1;
      overflow: hidden;
      backdrop-filter: blur(5px) contrast(200%) brightness(110%) saturate(150%);
      -webkit-backdrop-filter: blur(5px) contrast(200%) brightness(110%) saturate(150%);
      text-align: center;
    }
  
    #glass-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 150%;
      height: 150%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 70%);
      pointer-events: none;
      opacity: 0.6;
      filter: blur(40px);
      z-index: -1;
    }
  
    #text-container {
      max-width: 800px;
      line-height: 1.8;
      font-size: 7rem;
      text-align: center;
      font-family: 'Orbitron', 'DotGothic16';
      white-space: pre-wrap;
    }
  
    .char {
      opacity: 0;
      transform: translateY(20px);
      display: inline-block;
      white-space: pre;
    }
  </style>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@100..900&family=Orbitron:wght@400..900&family=Stick&display=swap" rel="stylesheet">
</head>
<body>
  <!-- グラスセクション -->
  <div id="glass-section">
    <div id="text-container"></div>
    <div id="glass-effect"></div>
  </div>

  <!-- Three.js & GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

  <script>
    let scene1, scene2, activeScene;
    let camera, renderer, tunnel, model, mixer;
    let t = 0;
    let isScene2Active = false;
    const clock = new THREE.Clock();
    const textParticles = [];
    const particleGroup = new THREE.Group();

    init();
    animate();

    function init() {
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.z = 0.1;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene1 = new THREE.Scene();
      const path = new (class extends THREE.Curve {
        getPoint(t) {
          const a = 100;
          const x = Math.sin(t * Math.PI * 4) * 5;
          const y = Math.cos(t * Math.PI * 6) * 5;
          const z = t * -a;
          return new THREE.Vector3(x, y, z);
        }
      })();
      const geometry = new THREE.TubeGeometry(path, 1200, 4, 12, false);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
      tunnel = new THREE.Mesh(geometry, material);
      scene1.add(tunnel);

      scene2 = new THREE.Scene();
      scene2.add(particleGroup);

      const fontLoader = new THREE.FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        const chars = ['1', '0'];
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

        for (let i = 0; i < 200; i++) {
          const char = chars[Math.floor(Math.random() * chars.length)];
          const textGeometry = new THREE.TextGeometry(char, {
            font: font,
            size: 0.5,
            height: 0.05
          });
          const mesh = new THREE.Mesh(textGeometry, textMaterial);
          mesh.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          particleGroup.add(mesh);
          textParticles.push(mesh);
        }
      });

      const loader = new THREE.GLTFLoader();
      loader.load("thriller.glb", function(gltf) {
        model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({
              color: 0x00ffff,
              wireframe: true
            });
          }
        });
        model.scale.set(1.5, 1.5, 1.5);
        model.position.set(0, -2, -4);
        model.visible = false;
        scene2.add(model);

        if (gltf.animations && gltf.animations.length) {
          mixer = new THREE.AnimationMixer(model);
          gltf.animations.forEach((clip) => {
            mixer.clipAction(clip).play();
          });
        }
      });

      activeScene = scene1;

      gsap.to({ t: 0 }, {
        t: 1,
        duration: 1,
        ease: "none",
        onUpdate: function () {
          t = this.targets()[0].t;
          const currentPoint = path.getPoint(t);
          const nextPoint = path.getPoint(Math.min(t + 0.002, 1));
          camera.position.copy(currentPoint);
          camera.lookAt(nextPoint);

          if (t >= 1 && !isScene2Active) {
            switchToScene2();
          }
        }
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (isScene2Active) updateCameraByViewport();
      });
    }

    function switchToScene2() {
      isScene2Active = true;
      activeScene = scene2;
      updateCameraByViewport();
      setTimeout(() => {
        mergeParticlesToModel();
      }, 500);
    }

    function mergeParticlesToModel() {
      const tl = gsap.timeline({
        onComplete: () => {
          particleGroup.visible = false;
          if (model) model.visible = true;

          setTimeout(() => {
            document.getElementById('glass-section').style.display = 'flex';
            document.body.style.overflow = 'auto';
            setupScrollSection();
          }, 2000);
        }
      });

      textParticles.forEach(p => {
        tl.to(p.position, {
          x: 0, y: 0, z: 0,
          duration: 1,
          ease: "power2.inOut"
        }, 0);
      });
    }

    function setupScrollSection() {
  gsap.registerPlugin(ScrollTrigger);

  const sentence = `Deku Design\nWEB & 3D\nCreator`;
  const container = document.getElementById("text-container");
  container.innerHTML = '';

  const chars = [];

  sentence.split('').forEach(char => {
    if (char === '\n') {
      const br = document.createElement("br");
      container.appendChild(br);
    } else {
      const span = document.createElement("span");
      span.classList.add("char");
      span.textContent = char;
      container.appendChild(span);
      chars.push(span);
    }
  });

  const staggerDuration = 2 / chars.length;

  ScrollTrigger.create({
    trigger: "#glass-section",
    start: "top top",
    onEnter: () => {
      stopScrolling();

      gsap.to(chars, {
        opacity: 1,
        y: 0,
        duration: 0.4,
        stagger: staggerDuration,
        ease: "power2.out",
        onComplete: () => {
          setTimeout(() => {
            allowScrolling();
          }, 500);
        }
      });
    },
    once: true
  });
}


// iOS含め全ブラウザでスクロール停止
function stopScrolling() {
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
  document.addEventListener('touchmove', preventDefault, { passive: false });
}

// スクロール再開
function allowScrolling() {
  document.body.style.overflow = 'auto';
  document.documentElement.style.overflow = 'auto';
  document.removeEventListener('touchmove', preventDefault, { passive: false });
}

// touchmove無効化関数
function preventDefault(e) {
  e.preventDefault();
}

    function updateCameraByViewport() {
      const w = window.innerWidth;
      if (w < 600) camera.position.set(0, 0, 7);
      else if (w < 1024) camera.position.set(0, 0, 5);
      else camera.position.set(0, 0, 4);
      camera.lookAt(0, 0, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (isScene2Active && mixer) mixer.update(clock.getDelta());
      renderer.render(activeScene, camera);
    }

    ScrollTrigger.create({
  trigger: "#glass-section",
  start: "bottom center",
  onEnter: () => {
    if (model.visible) {
      dissolveModelToParticles();
    }
  },
  once: true
});

function dissolveModelToParticles() {
  const particles = [];
  const dissolveGroup = new THREE.Group();
  scene2.add(dissolveGroup);

  const sampleRate = 20;

  model.traverse(child => {
    if (child.isMesh && child.geometry.isBufferGeometry) {
      const posAttr = child.geometry.attributes.position;
      const worldMatrix = child.matrixWorld;

      for (let i = 0; i < posAttr.count; i += sampleRate) {
        const vertex = new THREE.Vector3().fromBufferAttribute(posAttr, i);
        vertex.applyMatrix4(worldMatrix);

        const geo = new THREE.SphereGeometry(0.05, 4, 4);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(vertex);
        dissolveGroup.add(p);
        particles.push(p);
      }
    }
  });

  model.visible = false;

  const explosionDuration = 1.5;
  const gatherDuration = 1.0;
  const spiralTurns = 0.5; // 回転数（2〜5あたりがオススメ）

  const explosionTargets = [];

  particles.forEach((p, i) => {
    const dir = new THREE.Vector3(
      (Math.random() - 0.5),
      (Math.random() - 0.5),
      (Math.random() - 0.5)
    ).normalize().multiplyScalar(4 + Math.random() * 4);

    const angle = Math.random() * Math.PI * 2;
    const radius = dir.length();

    const target = {
      x: p.position.x + dir.x,
      y: p.position.y + dir.y,
      z: p.position.z + dir.z,
      angle: angle,
      radius: radius,
      baseY: p.position.y
    };

    explosionTargets.push(target);

    // 爆発
    gsap.to(p.position, {
      x: target.x,
      y: target.y,
      z: target.z,
      duration: explosionDuration,
      ease: "power2.out"
    });
  });

  // スパイラル収束
  gsap.delayedCall(explosionDuration, () => {
    particles.forEach((p, i) => {
      const target = explosionTargets[i];
      const startTime = performance.now();

      const spiral = () => {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / gatherDuration, 1);

        const angle = target.angle + progress * Math.PI * 2 * spiralTurns;
        const radius = target.radius * (1 - progress);

        p.position.x = Math.cos(angle) * radius;
        p.position.z = Math.sin(angle) * radius;
        p.position.y = THREE.MathUtils.lerp(target.y, 0, progress);

        if (progress < 1) {
          requestAnimationFrame(spiral);
        } else {
          p.position.set(0, 0, 0);

          if (i === 0) {
            scene2.remove(dissolveGroup);
            loadDanceGLB();
          }
        }
      };

      spiral();
    });
  });
}

function loadDanceGLB() {
  const loader = new THREE.GLTFLoader();
  loader.load("dance.glb", gltf => {
    const danceModel = gltf.scene;
    danceModel.scale.set(1.5, 1.5, 1.5);
    danceModel.position.set(0, -2, -4);
    danceModel.traverse(c => {
      if (c.isMesh) {
        c.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
      }
    });

    if (gltf.animations.length) {
      const newMixer = new THREE.AnimationMixer(danceModel);
      gltf.animations.forEach(clip => {
        newMixer.clipAction(clip).play();
      });
      mixer = newMixer;
    }

    scene2.add(danceModel);

    // カメラの回転＋接近アニメーション
    let angle = 0;
    const radius = 6;
    const duration = 2; // 秒
    const frames = duration * 60;
    let frame = 0;

    const animateCamera = () => {
      if (frame < frames) {
        angle = (frame / frames) * Math.PI * 2; // 0 → 2π
        camera.position.x = Math.cos(angle) * radius;
        camera.position.z = Math.sin(angle) * radius;
        camera.position.y = 2 - Math.sin((frame / frames) * Math.PI) * 1; // 少し上下する
        camera.lookAt(0, -2, -4);
        frame++;
        requestAnimationFrame(animateCamera);
      } else {
        // dance.glb表示後のカメラアニメーション
        gsap.to(camera.position, {
          duration: 2,
          ease: "power2.inOut",
          x: 3,     // 右へ
          y: -1.5,  // 下から
          z: -2,     // 近づく
          onUpdate: () => {
            danceModel.position.set(1, -4, -4);
            camera.lookAt(new THREE.Vector3(0, -2, -4)); // モデルを見続ける
          }
        });
      }
    };

    animateCamera();
  });
}

</script>

</body>
</html>
