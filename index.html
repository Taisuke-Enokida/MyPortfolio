<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Tunnel to Liquid Glass</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: 'Noto Sans JP', sans-serif;
      height: 500vh;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }

    #glass-section {
      margin: 50px;
      border-radius: 10px;
      position: relative;
      height: 100vh;
      top: 200vh;
      display: none;
      align-items: center;
      justify-content: center;
      background: #ffffff18;
      color: white;
      font-size: 48px;
      z-index: 1;
      overflow: hidden;
      backdrop-filter: blur(5px) contrast(200%) brightness(110%) saturate(150%);
      -webkit-backdrop-filter: blur(5px) contrast(200%) brightness(110%) saturate(150%);
      text-align: center;
      /* padding: 2rem; */
    }

    #glass-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 150%;
      height: 150%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 70%);
      pointer-events: none;
      opacity: 0.6;
      filter: blur(40px);
      z-index: -1;
    }

    #text-container {
    max-width: 800px;
    line-height: 1.8;
    font-size: 7rem;
    text-align: center;
    font-family: 'Orbitron', 'DotGothic16';
    white-space: pre-wrap;
  }

    .char {
      opacity: 0;
      transform: translateY(20px);
      display: inline-block;
      white-space: pre;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@100..900&family=Orbitron:wght@400..900&family=Stick&display=swap" rel="stylesheet">
</head>
<body>
  <!-- グラスセクション -->
  <div id="glass-section">
    <div id="text-container"></div>
    <div id="glass-effect"></div>
  </div>

  <!-- Three.js & GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

  <script>
    let scene1, scene2, activeScene;
    let camera, renderer, tunnel, model, mixer;
    let t = 0;
    let isScene2Active = false;
    const clock = new THREE.Clock();
    const textParticles = [];
    const particleGroup = new THREE.Group();

    init();
    animate();

    function init() {
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.z = 0.1;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene1 = new THREE.Scene();
      const path = new (class extends THREE.Curve {
        getPoint(t) {
          const a = 100;
          const x = Math.sin(t * Math.PI * 4) * 5;
          const y = Math.cos(t * Math.PI * 6) * 5;
          const z = t * -a;
          return new THREE.Vector3(x, y, z);
        }
      })();
      const geometry = new THREE.TubeGeometry(path, 1200, 4, 12, false);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
      tunnel = new THREE.Mesh(geometry, material);
      scene1.add(tunnel);

      scene2 = new THREE.Scene();
      scene2.add(particleGroup);

      const fontLoader = new THREE.FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        const chars = ['1', '0'];
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

        for (let i = 0; i < 200; i++) {
          const char = chars[Math.floor(Math.random() * chars.length)];
          const textGeometry = new THREE.TextGeometry(char, {
            font: font,
            size: 0.5,
            height: 0.05
          });
          const mesh = new THREE.Mesh(textGeometry, textMaterial);
          mesh.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          particleGroup.add(mesh);
          textParticles.push(mesh);
        }
      });

      const loader = new THREE.GLTFLoader();
      loader.load("thriller.glb", function(gltf) {
        model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshBasicMaterial({
              color: 0x00ffff,
              wireframe: true
            });
          }
        });
        model.scale.set(1.5, 1.5, 1.5);
        model.position.set(0, -2, -4);
        model.visible = false;
        scene2.add(model);

        if (gltf.animations && gltf.animations.length) {
          mixer = new THREE.AnimationMixer(model);
          gltf.animations.forEach((clip) => {
            mixer.clipAction(clip).play();
          });
        }
      });

      activeScene = scene1;

      gsap.to({ t: 0 }, {
        t: 1,
        duration: 3,
        ease: "none",
        onUpdate: function () {
          t = this.targets()[0].t;
          const currentPoint = path.getPoint(t);
          const nextPoint = path.getPoint(Math.min(t + 0.002, 1));
          camera.position.copy(currentPoint);
          camera.lookAt(nextPoint);

          if (t >= 1 && !isScene2Active) {
            switchToScene2();
          }
        }
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (isScene2Active) updateCameraByViewport();
      });
    }

    function switchToScene2() {
      isScene2Active = true;
      activeScene = scene2;
      updateCameraByViewport();
      setTimeout(() => {
        mergeParticlesToModel();
      }, 500);
    }

    function mergeParticlesToModel() {
      const tl = gsap.timeline({
        onComplete: () => {
          particleGroup.visible = false;
          if (model) model.visible = true;

          setTimeout(() => {
            document.getElementById('glass-section').style.display = 'flex';
            document.body.style.overflow = 'auto';
            setupScrollSection();
          }, 2000);
        }
      });

      textParticles.forEach(p => {
        tl.to(p.position, {
          x: 0, y: 0, z: 0,
          duration: 1,
          ease: "power2.inOut"
        }, 0);
      });
    }

    function setupScrollSection() {
  gsap.registerPlugin(ScrollTrigger);

  const sentence = `Deku Design\n3DCG\nCreator`;
  const container = document.getElementById("text-container");
  container.innerHTML = '';

  const chars = [];

  sentence.split('').forEach(char => {
    if (char === '\n') {
      const br = document.createElement("br");
      container.appendChild(br);
    } else {
      const span = document.createElement("span");
      span.classList.add("char");
      span.textContent = char;
      container.appendChild(span);
      chars.push(span);
    }
  });

  const staggerDuration = 5 / chars.length;

  ScrollTrigger.create({
    trigger: "#glass-section",
    start: "top top",
    onEnter: () => {
      stopScrolling();

      gsap.to(chars, {
        opacity: 1,
        y: 0,
        duration: 0.4,
        stagger: staggerDuration,
        ease: "power2.out",
        onComplete: () => {
          setTimeout(() => {
            allowScrolling();
          }, 500);
        }
      });
    },
    once: true
  });
}


// iOS含め全ブラウザでスクロール停止
function stopScrolling() {
  document.body.style.overflow = 'hidden';
  document.documentElement.style.overflow = 'hidden';
  document.addEventListener('touchmove', preventDefault, { passive: false });
}

// スクロール再開
function allowScrolling() {
  document.body.style.overflow = 'auto';
  document.documentElement.style.overflow = 'auto';
  document.removeEventListener('touchmove', preventDefault, { passive: false });
}

// touchmove無効化関数
function preventDefault(e) {
  e.preventDefault();
}

    function updateCameraByViewport() {
      const w = window.innerWidth;
      if (w < 600) camera.position.set(0, 0, 7);
      else if (w < 1024) camera.position.set(0, 0, 5);
      else camera.position.set(0, 0, 4);
      camera.lookAt(0, 0, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (isScene2Active && mixer) mixer.update(clock.getDelta());
      renderer.render(activeScene, camera);
    }
  </script>

</body>
</html>
